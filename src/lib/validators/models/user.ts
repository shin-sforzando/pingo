import { z } from "zod";
import { gameIdSchema, timestampSchema, ulidSchema } from "../common";

/**
 * Schema for individual notifications within the user's sub-collection.
 * Defines the structure and validation rules for notification documents.
 */
export const notificationSchema = z.object({
  // Using ULID for sortable unique IDs, useful for ordering notifications chronologically.
  id: ulidSchema,
  // Type categorizes the notification for potential filtering or icon display.
  type: z.enum([
    "system", // General system announcements
    "game_invite", // Invitation to join a game
    "game_start", // Game has started
    "game_end", // Game has ended
    "turn_reminder", // Reminder for player's turn (if applicable in future)
    "submission_accepted", // Photo submission was accepted
    "submission_rejected", // Photo submission was rejected
    "line_complete", // A bingo line was completed
    "game_complete", // The player completed the game requirements
    "friend_request", // Friend request received (if social features added)
    "achievement_unlocked", // Achievement unlocked (if gamification added)
  ]),
  // Determines how the notification should be presented to the user.
  displayType: z.enum(["toast", "popup", "inline"]),
  // The main content of the notification message.
  message: z.string().min(1).max(120), // Reasonable limits for display
  // Timestamp when the notification was created.
  createdAt: timestampSchema,
  // Flag indicating if the user has viewed the notification.
  read: z.boolean().default(false),
  // Optional link to a specific game related to this notification.
  relatedGameId: gameIdSchema.optional(),
  // A flexible field for additional data specific to the notification type.
  // Example: { rejectedReason: "inappropriate_content" } for submission_rejected.
  details: z.record(z.unknown()).optional(),
});

export type Notification = z.infer<typeof notificationSchema>;

/**
 * Schema for the main User document in the 'users' collection.
 * Defines the structure and validation rules for user data.
 */
export const userSchema = z.object({
  // User ID, corresponds to the Firebase Auth UID (a variable-length string generated by Firebase).
  // It's the primary key for the user document and cannot be customized to ULID.
  id: z.string().min(1, { message: "User ID cannot be empty." }),
  // Unique, user-chosen handle. Needs careful validation for uniqueness and allowed characters.
  // Adding regex for basic format validation (alphanumeric + underscore).
  // Note: Uniqueness validation needs to be handled at the application/database level (e.g., Firestore rules or checks).
  handle: z
    .string()
    .min(3, { message: "Handle must be at least 3 characters long." })
    .max(20, { message: "Handle must be no more than 20 characters long." })
    .regex(/^[a-zA-Z0-9_]+$/, {
      message: "Handle can only contain letters, numbers, and underscores.",
    }),
  // Timestamp of user account creation.
  createdAt: timestampSchema,
  // Timestamp of the user's last login. Useful for tracking activity.
  lastLoginAt: timestampSchema,
  // Array of game IDs the user is currently participating in.
  // Limited to 5 active games as per specification.
  participatingGames: z.array(gameIdSchema).max(5, {
    message: "Cannot participate in more than 5 games simultaneously.",
  }),
  // Array of game IDs the user has participated in previously.
  // Could potentially grow large; consider pagination or alternative tracking if needed long-term.
  gameHistory: z.array(gameIdSchema),
  // Optional field for user preferences or settings.
  // Example: { theme: 'dark', language: 'en' }
  settings: z.record(z.unknown()).optional(),
  // Optional field for profile information.
  profile: z
    .object({
      displayName: z.string().max(50).optional(),
      avatarUrl: z.string().url().optional(),
      bio: z.string().max(250).optional(),
    })
    .optional(),
});

export type User = z.infer<typeof userSchema>;
