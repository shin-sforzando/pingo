import { gameIdSchema } from "@/lib/validators/common";
import {
  boardSchema,
  gameSchema,
  participantSchema,
  playerBoardSchema,
} from "@/lib/validators/models/game";
import { gameParticipationSchema } from "@/lib/validators/models/gameParticipation";
import { userSchema } from "@/lib/validators/models/user";
import { http, HttpResponse } from "msw";
import { z } from "zod";
import { mockUsersDb } from "./userApi";

// --- Mock Data Store ---
// Using Record<GameId, Game> for easier lookup
export const mockGames: Record<string, z.infer<typeof gameSchema>> = {};
// Using Record<GameId, Record<UserId, Participant>>
export const mockParticipants: Record<
  string,
  Record<string, z.infer<typeof participantSchema>>
> = {};
// Using Record<GameId, Record<UserId, PlayerBoard>>
export const mockPlayerBoards: Record<
  string,
  Record<string, z.infer<typeof playerBoardSchema>>
> = {};
// Using Record<ParticipationId (e.g., `${userId}_${gameId}`), GameParticipation>
export const mockGameParticipations: Record<
  string,
  z.infer<typeof gameParticipationSchema>
> = {};

// --- Mock Session State (Simplified) ---
// Ideally, this would be imported or managed centrally with authHandlers state.
// Hardcoding for now to demonstrate dependent logic.
export const currentMockUserId: string | null = "mockuser1"; // Assume mockuser1 is logged in

// --- Helper Functions ---

/** Generates a simple 5x5 board with cycling subjects */
const generateMockBoard = (): z.infer<typeof boardSchema> => {
  const cells: z.infer<typeof boardSchema>["cells"] = [];
  const subjects = [
    "Cat",
    "Dog",
    "Tree",
    "Car",
    "House",
    "Flower",
    "Book",
    "Chair",
    "Table",
    "Lamp",
    "Phone",
    "Computer",
    "Key",
    "Bottle",
    "Cup",
    "Plate",
    "Fork",
    "Spoon",
    "Knife",
    "Shoe",
    "Hat",
    "Clock",
    "Cloud",
    "Sun",
    "Moon",
  ];
  for (let y = 0; y < 5; y++) {
    for (let x = 0; x < 5; x++) {
      const id = `cell-${x}-${y}`;
      const isFree = x === 2 && y === 2;
      cells.push({
        id,
        position: { x, y },
        subject: isFree
          ? "FREE"
          : subjects[
              (y * 5 + x + Math.floor(Math.random() * 5)) % subjects.length
            ], // Add some randomness
        isFree,
      });
    }
  }
  // Ensure the generated board conforms to the schema
  return boardSchema.parse({ cells });
};

/** Generates a unique, valid Game ID */
export const generateNewGameId = (): z.infer<typeof gameIdSchema> => {
  const chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ";
  let id: string;
  let attempts = 0;
  do {
    id = "";
    for (let i = 0; i < 6; i++) {
      id += chars.charAt(Math.floor(Math.random() * chars.length));
    }
    attempts++;
    if (100 < attempts)
      throw new Error("Failed to generate unique Game ID after 100 attempts"); // Prevent infinite loop
  } while (mockGames[id]); // Ensure uniqueness in mock DB
  // Validate the generated ID against the schema
  return gameIdSchema.parse(id);
};

// --- Schemas for Request Bodies ---

// Schema for creating a new game. Excludes server-generated fields and creatorId (taken from session).
const createGameSchema = gameSchema.omit({
  id: true, // Generated by server/mock
  createdAt: true, // Set by server/mock
  status: true, // Defaulted by server/mock
  board: true, // Generated by server/mock
  creatorId: true, // Taken from session
});

// Schema for updating game settings. Allows partial updates.
const updateGameSchema = gameSchema
  .pick({
    title: true,
    theme: true,
    isPublic: true,
    isPhotoSharingEnabled: true,
    requiredBingoLines: true,
    confidenceThreshold: true,
    notes: true,
    expiresAt: true, // Allow updating expiry
  })
  .partial();

// Schema for adding an admin.
const addAdminSchema = z.object({
  userId: userSchema.shape.id, // ID of the user to promote to admin
});

// --- MSW Handlers for /api/games/* ---

export const gameHandlers = [
  /**
   * POST /api/games/create
   * Creates a new game instance.
   */
  http.post("/api/games/create", async ({ request }) => {
    // Check mock session
    if (!currentMockUserId) {
      return HttpResponse.json({ message: "Unauthorized" }, { status: 401 });
    }
    const creatorId = currentMockUserId; // Use session user ID as creator

    try {
      const body = await request.json();
      // Parse the request body first (excluding creatorId)
      const parsedBody = createGameSchema.safeParse(body);

      if (!parsedBody.success) {
        return HttpResponse.json(
          {
            message: "Invalid game creation data",
            errors: parsedBody.error.flatten(),
          },
          { status: 400 },
        );
      }

      const gameData = parsedBody.data; // Contains validated fields except creatorId etc.
      const newGameId = generateNewGameId();
      const newBoard = generateMockBoard();
      const now = new Date();

      // Create the new game object, ensuring conformance to gameSchema
      const newGame: z.infer<typeof gameSchema> = gameSchema.parse({
        id: newGameId,
        // Spread validated data from the request body
        ...gameData,
        // Add server-set fields
        creatorId: creatorId, // Use the ID from the mock session
        createdAt: now,
        // Default expiry: 7 days from now, unless provided and valid
        expiresAt: gameData.expiresAt
          ? z.date().parse(gameData.expiresAt)
          : new Date(now.getTime() + 7 * 24 * 60 * 60 * 1000),
        status: "active", // Initial status
        board: newBoard,
      });

      // Store the new game and initialize related structures
      mockGames[newGameId] = newGame;
      mockParticipants[newGameId] = {};
      mockPlayerBoards[newGameId] = {};

      // --- Automatically add creator as participant ---
      const creatorParticipant: z.infer<typeof participantSchema> =
        participantSchema.parse({
          id: creatorId, // Use the creatorId from the session
          joinedAt: now,
          // Initial values for denormalized fields
          completedLines: 0,
          lastCompletedAt: null,
          submissionCount: 0,
        });
      mockParticipants[newGameId][creatorId] = creatorParticipant;

      // Create the creator's player board, marking the free cell if applicable
      const creatorPlayerBoard: z.infer<typeof playerBoardSchema> =
        playerBoardSchema.parse({
          userId: creatorId,
          cellStates: Object.fromEntries(
            newBoard.cells.map((cell) => [
              cell.id,
              {
                isOpen: cell.isFree,
                openedAt: cell.isFree ? now : null,
                openedBySubmissionId: null,
              },
            ]),
          ),
          completedLines: [],
        });
      mockPlayerBoards[newGameId][creatorId] = creatorPlayerBoard;

      // Create the GameParticipation document for the creator
      const creatorParticipation: z.infer<typeof gameParticipationSchema> =
        gameParticipationSchema.parse({
          userId: creatorId,
          gameId: newGameId,
          role: "creator", // Creator role
          joinedAt: now,
          // Initial denormalized values
          completedLines: 0,
          lastCompletedAt: null,
          submissionCount: 0,
        });
      // Use composite key for mock participations map
      mockGameParticipations[`${creatorId}_${newGameId}`] =
        creatorParticipation;

      console.log("[MSW] Created game:", newGameId);
      // Return the newly created game object
      return HttpResponse.json(newGame, { status: 201 }); // 201 Created
    } catch (error) {
      console.error("[MSW] /api/games/create Error:", error);
      if (error instanceof z.ZodError) {
        // Catch Zod errors during the final parse or helper validations
        return HttpResponse.json(
          {
            message: "Internal validation failed during game creation",
            errors: error.flatten(),
          },
          { status: 500 },
        );
      }
      return HttpResponse.json(
        { message: "Internal server error during game creation" },
        { status: 500 },
      );
    }
  }),

  /**
   * GET /api/games/:gameId
   * Retrieves details for a specific game.
   */
  http.get("/api/games/:gameId", ({ params }) => {
    const gameIdResult = gameIdSchema.safeParse(params.gameId);
    if (!gameIdResult.success) {
      return HttpResponse.json(
        { message: "Invalid Game ID format" },
        { status: 400 },
      );
    }
    const gameId = gameIdResult.data;
    const game = mockGames[gameId];

    if (!game) {
      return HttpResponse.json({ message: "Game not found" }, { status: 404 });
    }

    // --- Mock Access Control ---
    // Check if the game is public or if the current user is a participant/creator.
    const isParticipant =
      !!mockGameParticipations[`${currentMockUserId}_${gameId}`];
    if (!game.isPublic && !isParticipant) {
      return HttpResponse.json(
        { message: "Forbidden: You do not have access to this game" },
        { status: 403 },
      );
    }

    return HttpResponse.json(game);
  }),

  /**
   * POST /api/games/:gameId/join
   * Allows the current user to join an active game.
   */
  http.post("/api/games/:gameId/join", async ({ params }) => {
    // Check mock session
    if (!currentMockUserId) {
      return HttpResponse.json({ message: "Unauthorized" }, { status: 401 });
    }
    const joiningUserId = currentMockUserId; // Use the mock session user ID

    const gameIdResult = gameIdSchema.safeParse(params.gameId);
    if (!gameIdResult.success) {
      return HttpResponse.json(
        { message: "Invalid Game ID format" },
        { status: 400 },
      );
    }
    const gameId = gameIdResult.data;
    const game = mockGames[gameId];

    // Check if game exists and is active
    if (!game || game.status !== "active") {
      return HttpResponse.json(
        { message: "Game not found or is not active" },
        { status: 404 },
      );
    }

    // Check if user is already a participant
    const participationKey = `${joiningUserId}_${gameId}`;
    if (mockGameParticipations[participationKey]) {
      return HttpResponse.json(
        { message: "You have already joined this game" },
        { status: 409 },
      ); // Conflict
    }

    const now = new Date();

    // Add participant entry to the game's sub-collection mock
    const newParticipant: z.infer<typeof participantSchema> =
      participantSchema.parse({
        id: joiningUserId,
        joinedAt: now,
        completedLines: 0,
        lastCompletedAt: null,
        submissionCount: 0, // Initialize denormalized fields
      });
    if (!mockParticipants[gameId]) mockParticipants[gameId] = {}; // Ensure game entry exists
    mockParticipants[gameId][joiningUserId] = newParticipant;

    // Create the player's board state
    const newPlayerBoard: z.infer<typeof playerBoardSchema> =
      playerBoardSchema.parse({
        userId: joiningUserId,
        // Initialize cell states, marking free cell if present
        cellStates: Object.fromEntries(
          game.board.cells.map((cell) => [
            cell.id,
            {
              isOpen: cell.isFree,
              openedAt: cell.isFree ? now : null,
              openedBySubmissionId: null,
            },
          ]),
        ),
        completedLines: [],
      });
    if (!mockPlayerBoards[gameId]) mockPlayerBoards[gameId] = {}; // Ensure game entry exists
    mockPlayerBoards[gameId][joiningUserId] = newPlayerBoard;

    // Create the top-level GameParticipation document
    const newParticipation: z.infer<typeof gameParticipationSchema> =
      gameParticipationSchema.parse({
        userId: joiningUserId,
        gameId: gameId,
        role: "participant", // Default role for joining
        joinedAt: now,
        completedLines: 0,
        lastCompletedAt: null,
        submissionCount: 0, // Initialize denormalized fields
      });
    mockGameParticipations[participationKey] = newParticipation;

    console.log(`[MSW] User ${joiningUserId} joined game ${gameId}`);
    // Return success message and potentially the new participation record
    return HttpResponse.json(
      { message: "Successfully joined game", participation: newParticipation },
      { status: 200 },
    );
  }),

  /**
   * PUT /api/games/:gameId/update
   * Updates settings for an existing game (requires admin/creator role).
   */
  http.put("/api/games/:gameId/update", async ({ params, request }) => {
    // Check mock session
    if (!currentMockUserId) {
      return HttpResponse.json({ message: "Unauthorized" }, { status: 401 });
    }

    const gameIdResult = gameIdSchema.safeParse(params.gameId);
    if (!gameIdResult.success) {
      return HttpResponse.json(
        { message: "Invalid Game ID format" },
        { status: 400 },
      );
    }
    const gameId = gameIdResult.data;
    const game = mockGames[gameId];

    if (!game) {
      return HttpResponse.json({ message: "Game not found" }, { status: 404 });
    }
    if (game.status !== "active") {
      return HttpResponse.json(
        { message: "Cannot update inactive game" },
        { status: 400 },
      );
    }

    // --- Mock Authorization Check ---
    const participation =
      mockGameParticipations[`${currentMockUserId}_${gameId}`];
    if (!participation || !["creator", "admin"].includes(participation.role)) {
      return HttpResponse.json(
        {
          message: "Forbidden: Only creator or admin can update game settings",
        },
        { status: 403 },
      );
    }

    try {
      const body = await request.json();
      // Validate the incoming partial update data
      const parsedBody = updateGameSchema.safeParse(body);
      if (!parsedBody.success) {
        return HttpResponse.json(
          {
            message: "Invalid update data",
            errors: parsedBody.error.flatten(),
          },
          { status: 400 },
        );
      }

      // Apply updates to a copy of the game object
      const updatedGameData = { ...game, ...parsedBody.data };

      // Ensure the final object still conforms to the full game schema
      const validatedGame = gameSchema.parse(updatedGameData);

      // Update the game in the mock store
      mockGames[gameId] = validatedGame;
      console.log(`[MSW] Updated game ${gameId}`);
      return HttpResponse.json(validatedGame); // Return the updated game object
    } catch (error) {
      console.error(`[MSW] /api/games/${gameId}/update Error:`, error);
      if (error instanceof z.ZodError) {
        return HttpResponse.json(
          {
            message: "Internal validation failed after update",
            errors: error.flatten(),
          },
          { status: 500 },
        );
      }
      return HttpResponse.json(
        { message: "Internal server error during game update" },
        { status: 500 },
      );
    }
  }),

  /**
   * POST /api/games/:gameId/end
   * Marks a game as ended (requires admin/creator role).
   */
  http.post("/api/games/:gameId/end", ({ params }) => {
    // Check mock session
    if (!currentMockUserId) {
      return HttpResponse.json({ message: "Unauthorized" }, { status: 401 });
    }

    const gameIdResult = gameIdSchema.safeParse(params.gameId);
    if (!gameIdResult.success) {
      return HttpResponse.json(
        { message: "Invalid Game ID format" },
        { status: 400 },
      );
    }
    const gameId = gameIdResult.data;
    const game = mockGames[gameId];

    if (!game) {
      return HttpResponse.json({ message: "Game not found" }, { status: 404 });
    }

    // --- Mock Authorization Check ---
    const participation =
      mockGameParticipations[`${currentMockUserId}_${gameId}`];
    if (!participation || !["creator", "admin"].includes(participation.role)) {
      return HttpResponse.json(
        { message: "Forbidden: Only creator or admin can end the game" },
        { status: 403 },
      );
    }

    if (game.status === "ended") {
      return HttpResponse.json(
        { message: "Game has already ended" },
        { status: 400 },
      ); // Bad request or Conflict (409)
    }

    // Update game status
    game.status = "ended";
    console.log(`[MSW] Ended game ${gameId}`);
    // Return success message and the updated game state
    return HttpResponse.json({ message: "Game ended successfully", game });
  }),

  /**
   * GET /api/games/public
   * Retrieves a list of active public games.
   */
  http.get("/api/games/public", () => {
    const publicGames = Object.values(mockGames)
      .filter((game) => game.isPublic && game.status === "active")
      .sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime()); // Sort newest first
    // Return only essential fields for list view if needed
    const publicGameList = publicGames.map((g) => ({
      id: g.id,
      title: g.title,
      theme: g.theme,
      creatorId: g.creatorId, // Maybe get creator handle?
      createdAt: g.createdAt,
      expiresAt: g.expiresAt,
    }));
    return HttpResponse.json(publicGameList);
  }),

  /**
   * GET /api/games/participating
   * Retrieves a list of active games the current user is participating in.
   */
  http.get("/api/games/participating", () => {
    // Check mock session
    if (!currentMockUserId) {
      // Depending on API design, could return empty list or 401
      return HttpResponse.json([], { status: 200 }); // Return empty list if not logged in
      // return HttpResponse.json({ message: 'Unauthorized' }, { status: 401 });
    }

    // Find participation records for the current user
    const participatingGameIds = Object.keys(mockGameParticipations)
      .filter((key) => key.startsWith(`${currentMockUserId}_`))
      .map((key) => mockGameParticipations[key].gameId);

    // Get details for those games, filtering for active ones
    const participatingGames = participatingGameIds
      .map((gameId) => mockGames[gameId])
      .filter(
        (game): game is z.infer<typeof gameSchema> =>
          !!game && game.status === "active",
      ) // Type guard
      .sort((a, b) => b.createdAt.getTime() - a.createdAt.getTime()); // Sort newest first

    // Return essential fields for list view
    const participatingGameList = participatingGames.map((g) => ({
      id: g.id,
      title: g.title,
      theme: g.theme,
      creatorId: g.creatorId,
      createdAt: g.createdAt,
      expiresAt: g.expiresAt,
      // Maybe add user's role from participation?
      role: mockGameParticipations[`${currentMockUserId}_${g.id}`]?.role,
    }));

    return HttpResponse.json(participatingGameList);
  }),

  /**
   * POST /api/games/:gameId/admins/add
   * Promotes a participant to an admin role (requires creator role).
   */
  http.post("/api/games/:gameId/admins/add", async ({ params, request }) => {
    // Check mock session
    if (!currentMockUserId) {
      return HttpResponse.json({ message: "Unauthorized" }, { status: 401 });
    }

    const gameIdResult = gameIdSchema.safeParse(params.gameId);
    if (!gameIdResult.success) {
      return HttpResponse.json(
        { message: "Invalid Game ID format" },
        { status: 400 },
      );
    }
    const gameId = gameIdResult.data;
    const game = mockGames[gameId];

    if (!game) {
      return HttpResponse.json({ message: "Game not found" }, { status: 404 });
    }

    // --- Mock Authorization Check: Only Creator can add admins ---
    const currentUserParticipation =
      mockGameParticipations[`${currentMockUserId}_${gameId}`];
    if (
      !currentUserParticipation ||
      currentUserParticipation.role !== "creator"
    ) {
      return HttpResponse.json(
        { message: "Forbidden: Only the game creator can add admins" },
        { status: 403 },
      );
    }

    try {
      const body = await request.json();
      const parsedBody = addAdminSchema.safeParse(body);
      if (!parsedBody.success) {
        return HttpResponse.json(
          {
            message: "Invalid request body: requires userId",
            errors: parsedBody.error.flatten(),
          },
          { status: 400 },
        );
      }
      const { userId: userIdToAdd } = parsedBody.data;

      // Find the participation record for the user to be promoted
      const participationKey = `${userIdToAdd}_${gameId}`;
      const participationToUpdate = mockGameParticipations[participationKey];

      // Check if the target user is actually participating in the game
      if (!participationToUpdate) {
        return HttpResponse.json(
          {
            message:
              "User to be added as admin is not participating in this game",
          },
          { status: 400 },
        );
      }

      // Check if the user is already an admin or the creator
      if (participationToUpdate.role === "admin") {
        return HttpResponse.json(
          { message: "User is already an admin" },
          { status: 409 },
        ); // Conflict
      }
      if (participationToUpdate.role === "creator") {
        return HttpResponse.json(
          { message: "Cannot change the creator role" },
          { status: 400 },
        );
      }

      // Update the role in the participation record
      participationToUpdate.role = "admin";
      console.log(
        `[MSW] Promoted user ${userIdToAdd} to admin in game ${gameId}`,
      );
      // Return success message and the updated participation record
      return HttpResponse.json({
        message: "Admin added successfully",
        participation: participationToUpdate,
      });
    } catch (error) {
      console.error(`[MSW] /api/games/${gameId}/admins/add Error:`, error);
      return HttpResponse.json(
        { message: "Internal server error while adding admin" },
        { status: 500 },
      );
    }
  }),

  /**
   * GET /api/games/:gameId/participants
   * Retrieves a list of participants for a specific game.
   */
  http.get("/api/games/:gameId/participants", ({ params }) => {
    const gameIdResult = gameIdSchema.safeParse(params.gameId);
    if (!gameIdResult.success) {
      return HttpResponse.json(
        { message: "Invalid Game ID format" },
        { status: 400 },
      );
    }
    const gameId = gameIdResult.data;

    if (!mockGames[gameId]) {
      return HttpResponse.json({ message: "Game not found" }, { status: 404 });
    }

    // --- Mock Access Control ---
    // Allow access if game is public or user is participant
    const isParticipant =
      !!mockGameParticipations[`${currentMockUserId}_${gameId}`];
    if (!mockGames[gameId].isPublic && !isParticipant) {
      return HttpResponse.json(
        {
          message:
            "Forbidden: You do not have access to this game's participant list",
        },
        { status: 403 },
      );
    }

    // Get participant summaries from the game's sub-collection mock
    const participantsList = Object.values(mockParticipants[gameId] || {});

    // Optionally enrich with user handle/role from mockUsersDb if needed by frontend
    const enrichedParticipants = participantsList.map((p) => {
      const user = mockUsersDb.find((u) => u.id === p.id);
      const participation = mockGameParticipations[`${p.id}_${gameId}`];
      return {
        ...p,
        handle: user?.handle,
        role: participation?.role, // Add role info
      };
    });

    return HttpResponse.json(enrichedParticipants);
  }),
];
